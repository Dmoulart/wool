
add :: first, second -> f32
{ 
  first + second + 1.5
}

main :: -> void
{
  sum :: add(1, 1.5)
}

/* 

global_var  : i32 = 0 // -> Globals.put('global_var')
global_var_2: i32 = 0

b :: -> {
  local_var: i32 = 0 // -> Locals.put('local_var')
}

a :: -> {
  local_var: f32 = 1 // -> Locals.put('local_var')
}

*/


/* 
// log :: from console import log

add :: first, second -> 
{ 
  first + second + 1.5
}

main :: -> void {
  sum :: add(1, 1.5)

  log(sum)
}
*/


/*
test_float_coercion :: {
  b := 1 
  c := 2

  if (c == 1.5) c else b // should coerce b and c to float !
}
*/

/*
// the problematic propagation case
a := 1.5 + (2 + 3 + (4 - 5))
*/

/*
a :: 1 // <- Number

b :: 2 // <- Number

// (add is a virtual/abstract (generic) function as long as it contains a non terminal type)
add :: first, second ->
{ 
  first + second 
}

// (main is always an "concrete" (non-generic) function)
main :: -> {

  // <- Number
  sum := add(a, b)

  // <- Float
  sum + 1.5 

}

// (an actual function types should always be resolved to terminal types)
*/